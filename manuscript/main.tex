\documentclass[12pt]{article}

\usepackage{amsmath, amsthm, amssymb}
\usepackage{amssymb}
\usepackage{bbm}

\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}
\usepackage{url}

%%% For figures
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

%%% For tables
\usepackage[table]{xcolor}

%specifying table and figure packages
\usepackage{caption}

\usepackage[T1]{fontenc}
\usepackage[all]{xy}
\usepackage[inline]{enumitem}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}

\newcommand{\mattia}[1]{\textcolor{cyan}{#1}}
\newcommand{\pietro}[1]{\textcolor{teal}{#1}}
\newcommand{\Ban}{{\mathbf{Ban}}}
\newcommand{\Top}{{\mathbf{Top}}}
\newcommand{\coforget}{{\textnormal{coforget}}}
\newcommand{\cofree}{{\textnormal{cofree}}}
\newcommand{\pt}{{\textnormal{pt}}}
\newcommand{\Hom}{{\textnormal{Hom}}}
\newcommand{\End}{{\textnormal{End}}}
\newcommand{\Fun}{{\textnormal{Fun}}}
\newcommand{\Aut}{{\textnormal{Aut}}}
\newcommand{\Obj}{{\textnormal{Obj}}}
\newcommand{\id}{{\textnormal{id}}}
\newcommand{\Morph}{{\textnormal{Morph}}}
\newcommand{\Set}{{\mathbf{Set}}}
\newcommand{\Mon}{{\mathbf{Mon}}}
\newcommand{\Cat}{{\mathbf{C}}}
\newcommand{\JCat}{{\mathbf{J}}}
\newcommand{\LCat}{{\mathbf{L}}}
\newcommand{\QCat}{{\mathbf{Q}}}
\newcommand{\range}[2]{{\{{#1}, \dots,{#2}\}}}
\newcommand{\anon}{{\,\mbox{-}\,}}

\crefname{diagram}{diag.}{diags.}
\Crefname{diagram}{Diagram}{Diagrams}
\creflabelformat{diagram}{#2(#1)#3}

\title{Weight sharing via dependent products}
\author{
    Pietro Vertechi \and Mattia G. Bergomi
}
\date{}
\begin{document}
\maketitle
\begin{abstract}
\end{abstract}

\section{Architecture}

\begin{definition}\label{def:architecture}
    Let $\Cat$ be a Cartesian closed category. An {\em architecture} is a Cartesian closed category $\Cat$ together with a comonad $T\colon \Cat \rightarrow \Cat$ that preserves finite products.
\end{definition}

\pietro{Questo teorema e' noto ma credo valga la pena menzionarlo.}

\begin{theorem}\label{thm:categorical_architecture}
    Let $\QCat$ be a locally Cartesian closed category. Then, there is a well defined notion of category {\em internal} to $\QCat$~\cite{mac2013categories}.
    Let $\JCat = s, t \colon C_1 \rightarrow C_0$ be such an internal category. $\JCat$ induces an architecture
    \begin{equation*}
        s_!t^*\colon \QCat/C_0 \rightarrow \QCat/C_0.
    \end{equation*}
\end{theorem}

\begin{proof}
    The map $t_*s^*\colon \QCat/C_0 \rightarrow \QCat/C_0$ is a monad~\cite[Thm.~V.8.2]{Mac_Lane_1994}. As $\QCat$ is locally Cartesian closed, $s^*$ has a right adjoint $s_!$, hence we can consider $s_!t^*$. As $T = s_!t^*$ is the right adjoint of the monad $t_*s^*$, it is a comonad. Being a right adjoint, $T$ preserves finite products.
\end{proof}

Let $T$ be an architecture on $\Cat$.
We can consider two distinct categories, $\Cat^T$ and $\Cat_T$, the Eilenberg-Moore and Kleisli categories for the comonad $T$, respectively.

\begin{theorem}\label{thm:cartesian_kleisli}
    Let $T\colon \Cat \rightarrow \Cat$ be an architecture. Then both $\Cat_T$ and $\Cat^T$ have finite products, and all functors
    \begin{equation*}
        \Cat_T \rightarrow \Cat^T \rightarrow T
    \end{equation*}
    preserve them. Furthermore $\Cat_T$ is Cartesian closed and it is powered over $\Cat^T$. Given a coalgebra $M$ and a cofree coalgebra $\cofree(X)$, we denote this operation
    \begin{equation*}
        \pitchfork(M, \cofree(X)) \simeq \cofree\left([\coforget(M), X]\right).
    \end{equation*}
    \pietro{Forse addirittura rimuovendo $C_T$ si puo' fare power in $C$ direttamente.}
\end{theorem}

\section{Equivariance}

\pietro{TODO: do with power!}

One of the key reasons for the success of neural networks is the notion of {\em weight sharing}. In its simplest form, one can consider, among maps $[M, X] \rightarrow [M, X]$, those that originate from maps $[M, X] \rightarrow X$. Indeed, given
\begin{equation*}
    {\cal F} \colon [M, X] \rightarrow X,
\end{equation*}
one can consider the map
\begin{align*}
    \widehat{\cal F} \colon [M, X] &\rightarrow [M, X] \\
    \left(\widehat{\cal F}\phi\right)(m) &= {\cal F}(a \mapsto \phi(ma)).
\end{align*}

This simple notion of weight sharing does not seem sufficient to cover complex neural networks, made up of several nodes, each with their own symmetries, which interact with each other in non-trivial ways.

We aim to show that the simple notion of weight sharing defined above is sufficient to recover, among other examples, classical recurrent and convolutional neural networks. However, to do so, we will need to generalize not the weight sharing strategy, but rather the underlying category on which such strategy takes place.

\section{Locality}

\pietro{Fai la localita' in termini di sottoggetti di M. Funziona?}

% \section{Architectures in quasitopoi}

% Same as above but in an arbitrary quasitopos.
% \Cref{thm:categorical_architecture} holds as is, with internal categories in the quasitopos. Monoids becomes $F \rightarrow O \in \Cat/O$. Preorder is $R \subseteq O \times O$ (strong mono). $R$ induces a monad on $\Cat/O$ (always~\cite[Thm.~V.8.2]{Mac_Lane_1994}). We need an algebra in $\Mon(\Cat/O)$ for that monad. It is a bit worrying that it does not preserve products.

% Even better, take the slice category already as quasitopos! Then you need a monoid and a monad. Much easier! $F$ should be a monoid in the category of coalgebras for the category $R$.

% As examples, distance spaces, sequential spaces, etc.

\section{Comonadic machines}

Show how it's possible to obtain a machine from an architecture.

\section{Recurrent and convolutional neural networks}

Monoids can be considered as categories with one object. Let us consider the category corresponding to $\mathbb N$. Let $M$ be the set containing only the generator morphism. Then the above construction recovers recurrent neural networks. Analogously, considering $\mathbb N \times \mathbb N$ we obtain convolutional neural networks, where $M$ denotes the shape of the filter.
\pietro{TODO: mention 2 objects for conv, and strides!}
\pietro{Maybe also do functors, to generalize GENEO? Somehow discuss continuous version?}

\section{Novel architectures}

Here, we explore the scenario where the category $\Cat$ has more than one object.
\pietro{TODO: figure out a good application.}
\pietro{Mention partial symmetries because of non-composability.}

\bibliographystyle{abbrv}
\bibliography{References}

\end{document}
