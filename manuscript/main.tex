\documentclass[12pt]{article}

\usepackage{amsmath, amsthm, amssymb}
\usepackage{amssymb}
\usepackage{bbm}

\usepackage[hidelinks]{hyperref}
\usepackage{cleveref}
\usepackage{url}

%%% For figures
\usepackage{graphicx}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

%%% For tables
\usepackage[table]{xcolor}

%specifying table and figure packages
\usepackage{caption}

\usepackage[T1]{fontenc}
\usepackage[all]{xy}
\usepackage[inline]{enumitem}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}

\newcommand{\mattia}[1]{\textcolor{cyan}{#1}}
\newcommand{\pietro}[1]{\textcolor{teal}{#1}}
\newcommand{\N}{{\mathbb{N}}}
\newcommand{\Ban}{{\mathbf{Ban}}}
\newcommand{\Top}{{\mathbf{Top}}}
\newcommand{\pt}{{\textnormal{pt}}}
\newcommand{\Hom}{{\textnormal{Hom}}}
\newcommand{\End}{{\textnormal{End}}}
\newcommand{\Fun}{{\textnormal{Fun}}}
\newcommand{\Aut}{{\textnormal{Aut}}}
\newcommand{\Obj}{{\textnormal{Obj}}}
\newcommand{\id}{{\textnormal{id}}}
\newcommand{\Morph}{{\textnormal{Morph}}}
\newcommand{\Set}{{\mathbf{Set}}}
\newcommand{\Cat}{{\mathbf{C}}}
\newcommand{\DCat}{{\mathbf{D}}}
\newcommand{\ICat}{{\mathcal{I}}}
\newcommand{\JCat}{{\mathcal{J}}}
\newcommand{\LCat}{{\mathbf{L}}}
\newcommand{\QCat}{{\mathbf{Q}}}
\newcommand{\range}[2]{{\{{#1}, \dots,{#2}\}}}
\newcommand{\anon}{{\,\mbox{-}\,}}

\crefname{diagram}{diag.}{diags.}
\Crefname{diagram}{Diagram}{Diagrams}
\creflabelformat{diagram}{#2(#1)#3}

\title{Weight sharing via comonads}
\author{
    Pietro Vertechi \and Mattia G. Bergomi
}
\date{}
\begin{document}
\maketitle
\begin{abstract}
\end{abstract}

\section{Architecture}


\begin{definition}\label{def:cartesian_category}
    We say that a category is {\em Cartesian} if it has finite products. We say that a functor between Cartesian categories is Cartesian if it preserves finite products.
\end{definition}

\begin{definition}\label{def:nilpotent_functor}
    A functor $T$ is {\em nilpotent} if there exists $n \in \N$ such that the composed functor $T^n$ maps all objects to the terminal object.
\end{definition}

We begin by giving an abstract definition of {\em nilpotent architecture}.

\begin{definition}\label{def:nilpotent_architecture}
    Let $\Cat$ be a Cartesian category. A {\em nilpotent architecture} is a nilpotent Cartesian endofunctor $T \colon \Cat \rightarrow \Cat$.
\end{definition}

This is sufficient to give notions of composability, weight sharing, and locality. In the reminder of the section, we will first give a broad class of architectures. Then, we will consider a simpler special case and show that it is sufficient to recover, among other examples, classical recurrent and convolutional neural networks.

\subsection{Examples}

\begin{proposition}\label{prop:graph_architecture}
    Let $(E, V)$ be a directed acyclic graph. Let $\DCat$ be a Cartesian category. The functor
    \begin{align*}
        T \colon \DCat^V &\rightarrow \DCat^V \\
        (T X)(v) &= \prod_{u \in in(v)} X(u),  
    \end{align*}
    where $in(v)$ is the set of incoming neighbors of $v$, is a nilpotent architecture.
\end{proposition}

\begin{proof}
    It is straightforward to verify that $T$ preserves finite products. Let $n$ be such that there are no paths of length $n$ in $(V, E)$. Then $T^n X$ is the terminal object.
\end{proof}

\Cref{prop:graph_architecture} has a continuous analogue in locally Cartesian closed categories.
\begin{proposition}\label{[prop]:categorical_architecture}
    Let $\QCat$ be a locally Cartesian closed category. Let $s, t\colon E \rightarrow V$ be two parallel arrows. Let us assume that there exists $n \in \N$ such that the iterated pullback
    \begin{equation}\label{eq:nilpotent_left_adjoint}
       \underbrace{E \times_V E \times_V \dots \times_V E}_{n \text{ factors}}
    \end{equation}
    is initial in $\QCat/V$.
    Then
    \begin{equation*}
        s_!t^*\colon \QCat/V \rightarrow \QCat/V
    \end{equation*}
    is a nilpotent architecture on $\QCat/V$.
\end{proposition}

\begin{proof}
    The functor $s_!t^*$ is the right adjoint of  $t_*s^*\colon \QCat/C_0 \rightarrow \QCat/C_0$, and therefore it is Cartesian. By~\cref{eq:nilpotent_left_adjoint}, $(t_*s^*)^n$ maps all objects to the initial object, so its adjoint $(s_!t^*)^n$ maps all objects to the terminal object.
\end{proof}

\section{Weight sharing}

One of the key reasons for the success of neural networks is the notion of {\em weight sharing}. In its simplest form, one can consider, among maps $[M, X] \rightarrow [M, X]$, those that originate from maps $[M, X] \rightarrow X$. Indeed, given
\begin{equation*}
    {\cal F} \colon [M, X] \rightarrow X,
\end{equation*}
one can consider the map
\begin{align*}
    \widehat{\cal F} \colon [M, X] &\rightarrow [M, X] \\
    \left(\widehat{\cal F}\phi\right)(m) &= {\cal F}(a \mapsto \phi(ma)).
\end{align*}

This simple notion of weight sharing does not seem sufficient to cover complex neural networks, made up of several nodes, each with their own symmetries, which interact with each other in non-trivial ways.

We aim to show that the simple notion of weight sharing defined above is sufficient to recover, among other examples, classical recurrent and convolutional neural networks. However, to do so, we will need to generalize not the weight sharing strategy, but rather the underlying category on which such strategy takes place.

Here, we consider how to define a notion of weight sharing given a nilpotent architecture $T\colon\Cat \rightarrow \Cat$. Let $T$ be a nilpotent architecture on a Cartesian closed category $\Cat$. Let $\Cat^T$ be category of coalgebras for the functor $T$. $\Cat^T$ also has finite products given by
\begin{equation*}
    \prod_{i=1}^k A_i \rightarrow \prod_{i=1}^k T A_i \simeq T \prod_{i=1}^k A_i.
\end{equation*}
The coforgetful functor $U\colon \Cat^T \rightarrow \Cat$ has a right adjoint
\begin{align*}
    F \colon \Cat &\rightarrow \Cat^T\\
    X &\mapsto X \times T X \times \dots \times T^{n-1} X,
\end{align*}
called the cofree functor. 

\begin{proposition}\label{prop:cofree_exponentiating}
    Let $T\colon \Cat \rightarrow \Cat$ be a nilpotent architecture. Then cofree coalgebras in $\Cat^T$ are exponentiating. More explicitly, let $F\colon \Cat \rightarrow \Cat^T$ denote the cofree functor. Then, there exists a natural isomorphism
    \begin{equation*}
        \Hom(A\times B, FX) \simeq \Hom(A, F[UB, X]).
    \end{equation*}
\end{proposition}

\begin{proof}
    By a straightforward computation:
    \begin{align*}
        \Hom_{\Cat^T}(A\times B, FX)
        &\simeq \Hom_{\Cat}(U(A \times B), X)\\
        &\simeq \Hom_{\Cat}(UA \times UB, X)\\
        &\simeq \Hom_{\Cat}(UA, [UB, X])\\
        &\simeq \Hom_{\Cat^T}(A, F[UB, X]).
    \end{align*}
\end{proof}

\begin{theorem}\label{thm:weight_sharing}
    Let $M \in \Cat^T$ be a monoid. Then $M$ induces a comonad:
    \begin{equation*}
        X \mapsto UF[UM, X].
    \end{equation*}
\end{theorem}

\begin{proof}
    Monoidal functor
    \begin{align*}
        \left(\Cat^T\right)^{op} &\rightarrow \Fun(\Cat_T, \Cat_T)\\
        M &\mapsto [M, \anon],
    \end{align*}
    hence monoid goes to comonad. That, and free forget from Kleisli to $\Cat$.
\end{proof}

\section{Comonadic machines}

Show how it's possible to obtain a machine from an architecture.

\section{Recurrent and convolutional neural networks}

Monoids can be considered as categories with one object. Let us consider the category corresponding to $\N$. Let $M$ be the set containing only the generator morphism. Then the above construction recovers recurrent neural networks. Analogously, considering $\N \times \N$ we obtain convolutional neural networks, where $M$ denotes the shape of the filter. \pietro{Update this part, it no longer makes sense.}
\pietro{TODO: mention 2 objects for conv, and strides!}
\pietro{Maybe also do functors, to generalize GENEO? Somehow discuss continuous version?}

\section{Novel architectures}

Here, we explore the scenario where the category $\Cat$ has more than one object.
\pietro{TODO: figure out a good application.}
\pietro{Mention partial symmetries because of non-composability.}

\bibliographystyle{abbrv}
\bibliography{References}

\end{document}
